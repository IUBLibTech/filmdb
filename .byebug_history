c
value.size
c
value.size
value
record.titles.size
record
value
c
titles.size
c
exit
physical_object.current_workflow_status.nil? && status_name != JUST_INVENTORIED
status_name
c
ApplicationHelper.valid_barcode?(value)
ApplicationHelper.barcode_assigned?(value)
value
c
others
exit
all.size
all
others
c
@physical_object
c
@physical_object
c
@msg
@physical_object.workflow
@physical_object
exit
WorkflowStatus::IN_STORAGE_INGESTED
c
ingested
c
WorkflowStatus.where(physical_object_id: id, status_name: WorkflowStatus::IN_STORAGE_INGESTED).size > 0
in_freezer?
awaiting_freezer?
awaiting_freeer?
exit
po.storage
exit
po.attributes
po.storage
po
c
@physical_object.valid?
exit
@physical_object.errors
@physical_object.valid?
@physical_object.workflow_statuses.first
@physical_object.workflow_statuses[0]
@physical_object.workflow_statuses.first
@physical_object.workflow_statuses
@physical_object
c
"#{cedar['upload_dir']}/#{file}"
file
file_name
exit
"#{cedar['upload_dir']}/#{file}"
file
cedar['upload_dir']
#{cedar['upload_dir']}/#{file}
file_name
c
file
exit
?
f
file_name.split('/')[-1]
f
c
file_name.split('/')[-1]
c
Rails.configuration.cedar
exit
c
@physical_object
exit
c
po.location
location
c
po.send(:edge_code=, '1964')
HEADERS_TO_ASSIGNER['Edge Code Date']
HEADERS_TO_ASSIGNER.keys.each do |k| puts k end
po
c
exit
cedar['password']
c
cg.group_type
c
exit
self.workflow_status_template_id == other..workflow_status_template_id
self.workflow_status_location_id == other.workflow_status_location_id
self.workflow_status_location_id
self.class == other.class
c
config.cedar
exit
action_name
controller_name.humanize.split.map(&:capitalize)*' '
controller_name.humanize
controller_name.split.map(&:capitalize)*' '
controller_name.split.map(&.capitalize)*' '
controller_name.split,map(&.capitalize)*' '
controller_name.upcase
controller_name.camelize
controller_name
exception
exception.attributes
exception.message
exception
exception.policy.class
exception.policy
c
current_user_object
exit
current_user_object
exit
ApplicationHelper.current_user_object
current_user_object
exit
Cage.where(ready_to_ship: true)
@cages.size
@cages
c
po
c
@cages.each do |c| puts c.identifier end
@cages.each do |c| puts c.indentifier end
@cages.class
@cages.size
@cages
c
@cage
c
@cage
c
@physical_objects.size
@physical_objects
exit
EXIT
ids
c
ch
c
ch
c
ch.class
c
ch
c
ch
c
ch
c
ch
c
exit
c
ids
footage
c
footage
c
footage
ids
c
params
params[:ids]
exit
WorkflowStatusTemplate::PULL_REQUEST_QUEUED
WorkflowStatusTemplate::STATUS_TO_TEMPLATE_ID
c
!flash[:notice].blank? || !flash.now[:notice].blank?
!flash[:warning].blank? || !flash.now[:warning].blank?
unless !flash[:warning].blank? || !flash.now[:warning].blank?
flash[:notice]
c
!po.mdpi_barcode.nil? && !po.mdpi_barcode != mbc.to_i
c
n
po
bc
exit
po
bc
c
@physical_object
@physical_object.mdpi_barcode
@msg
n
c
@err
c
@po.current_workflow_status.status_type != WorkflowStatusTemplate::ON_SITE
c
@po.current_workflow_status.status_type != WorkflowStatusTemplate::ON_SITE
@po.current_workflow_status.type_and_location
c
physical_location
exit
WorkflowStatusTemplate::STATUS_TO_TEMPLATE_ID
c
contents
exit
contents.join("\n")
contents
c
@result.body
@result.key
@result.keys
@result.attributes
@result.class
@result.attributes
@result
c
exit
c
@cage
exit
SecureRandom.base64(64)
SecureRandom.base64(32)
SecureRandom.base64(31)
SecureRandom.base64(32)
c
URI.parse(Rails.configuration.pod_batch_url).request_uri
URI.parse(Rails.configuration.pod_batch_url)
c
cage.top_shelf.physical_objects
exit
PhysicalObject.where(iu_cat
params
@physical_object
c
xml.format cage.top_shelf&.physical_objects&.first
xml.format cage.top_shelf&.physical_objects&.first.medium
xml.format cage.top_shelf&.physical_objects
c
cage
exit
PhysicalObject.first.inventorier
PhysicalObject.first
c
User.first
c
@physical_object.physical_object_titles.size
c
@physical_object.physical_object_titles.size
@physical_object.physical_object_titles
@physical_object.titles.size
