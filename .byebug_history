exit
match
c
date
match
exit
/^([\[\]0-9\/\?]+( [-\xE2\x80\x94\xE2\x80\x93]{1,1} ?[\[\]0-9]+)?)( \(([a-zA-Z ]+)\))?$/.match(date)
date
c
exit
date
exit
date
exit
/^([0-9 -\[\]]+)\(([a-zA-Z ]+)\){0,1}$/.match(date)
/^([0-9 -\[\]]+) [\(([a-zA-Z ]+\))]{0,1}$/.match(date)
match
date
match
c
match
c
match
c
match
c
match
c
match
c
match
c
match
c
match
c
exit
params
exit
collection_id
exit
sql
c
sql
c
collection_id.blank?
date.blank?
publisher_text.blank?
c
publisher_text.blank?
publisher_text
c
params
c
params
c
td.date_to_s
c
td.to_s
c
td.to_s
self.to_string
td
c
td.to_s
td
c
self.to_s
self.to_string
self
c
self
c
options_for_select(@title_date_cv[:date_type])
@title_date_cv
c
exit
params[:cage][:mdpi_barocde]
c
!@physical_object.current_workflow_status.valid_next_workflow?(WorkflowStatus::IN_CAGE)
@physical_object.current_workflow_status.valid_next_workflow?(WorkflowStatus::IN_CAGE)
exit
@physical_object.current_workflow_status.valid_next_workflow?(WorkflowStatus::IN_CAGE)
exit
@physical_object.current_workflow_status.valid_next_workflow?(WorkflowStatus::IN_CAGE)
@physical_object.current_workflow_status
@physical_object.current_workflow_status.valid_next_workflow?(WorkflowStatus::IN_CAGE)
exit
params[:cage]
params[:cage].&[:physical_object_mdpi_barcode]
exit
mbc
c
NONPACKABLE_GAUAGES.include?(@physical_object.gauge)
exit
c
PhysicalObjectsHelper::GAUGES_TO_FRAMES_PER_FOOT["16mm"]
exit
PhysicalObjectsHelper::GAUGES_TO_FRAMES_PER_FOOT["16mm"]
PhysicalObjectsHelper.reload
PhysicalObjectsHelper.reload!
PhysicalObjectsHelper::GAUGES_TO_FRAMES_PER_FOOT["16mm"]
PhysicalObjectsHelper::GAUGES_TO_FRAMES_PER_FOOT
PhysicalObjectsHelper::GAUGES_TO_FRAMES_PER_FOOT[p.gauge.to_s]
PhysicalObjectsHelper::GAUGES_TO_FRAMES_PER_FOOT[p.gauge]
p.gauge
c
p.current_workflow_status.component_group
c
(STATUS_TYPES_TO_STATUSES['Storage'] << DEACCESSIONED).include?(status_name) ? nil : physical_object.active_component_group.id
exit
(STATUS_TYPES_TO_STATUSES['Storage'] << DEACCESSIONED).include? status_name ? nil : physical_object.active_component_group.id
(STATUS_TYPES_TO_STATUSES['Storage'] << DEACCESSIONED).include? status_name
(STATUS_TYPES_TO_STATUSES['Storage'] << DEACCESSIONED).include?(status_name) ? nil : physical_object.active_component_group.id
(STATUS_TYPES_TO_STATUSES['Storage'] << DEACCESSIONED).include? status_name
status_name
(STATUS_TYPES_TO_STATUSES['Storage'] << DEACCESSIONED).include? status_name ? nil : physical_object.active_component_group.id
(STATUS_TYPES_TO_STATUSES['Storage'] << DEACCESSIONED).include? status_name ? nil : physical_object.active_component_group.id)
((STATUS_TYPES_TO_STATUSES['Storage'] << DEACCESSIONED).include? status_name ? nil : physical_object.active_component_group.id))
c
ws
w
c
physical_object.active_component_group
physical_object
p
c
p.active_component_group
exit
ControlledVocabulary.physical_object_cv
ControlledVocabulary
@cv[attr_symbol]
attr_symbol
val
exit
Series.series_not_in_spreadsheet(params[:series].to_i, @spreadsheet)
Series.series_in_spreadsheet(Series.find(params[:series].to_i).title, @spreadsheet.id).size
Series.series_in_spreadsheet(Series.find(params[:series].to_i).title, @spreadsheet.id)
Series.find(params[:series].to_i).title
exit
Series.find(params[:series].to_i).title
params[:series].to_i
eries.find(params[:series].to_i).title
eries.find(params[:series]).title
params[:series]
exit
ComponentGroup.new
cg
c
exit
cg
exit
cg.foobar = 'wtf?'
ComponentGroup.last
cg.reload
cg.reload!
cg.save
cg
c
@physical_object.footage.blank? && params[:physical_object][:footage].blank? && @physical_object.active_component_group.group_type != ComponentGroup::BEST_COPY_ALF
WorkflowStatus::BEST_COPY_ALF
exit
WorkflowStatus::BEST_COPY_ALF
c
WorkflowStatus::BEST_COPY_ALF
@physical_object.active_component_group.group_type
@physical_object.active_component_group.group_type != WorkflowStatus::BEST_COPY_ALF
@physical_object.footage.blank? && params[:physical_object][:footage].blank? && @physical_object.active_component_group.group_type != WorkflowStatus::BEST_COPY_ALF
c
WorkflowStatus::BEST_COPY_ALF
@physical_object.active_component_group.group_type
@physical_object.active_component_group.group_type != WorkflowStatus::BEST_COPY_ALF
@physical_object.footage.blank? && params[:physical_object][:footage].blank?
@physical_object.footage.blank? && params[:physical_object][:footage].blank? && @physical_object.active_component_group.group_type != WorkflowStatus::BEST_COPY_ALF
exit
c
@user
c
@user
c
@user
c
@user
c
WorkflowStatus::STATUSES_TO_NEXT_WORKFLOW[@physical_object.current_workflow_status.previous_sibling.status_name].collect{ |s| [s,s] }c
WorkflowStatus::STATUSES_TO_NEXT_WORKFLOW[@physical_object.current_workflow_status.previous_sibling.status_name].collect{ |s| [s,s] }
WorkflowStatus::STATUSES_TO_NEXT_WORKFLOW[@physical_object.current_workflow_status.previous_sibling.status_name]
@physical_object.current_workflow_status.previous_sibling.status_name
c
@physical_object.current_workflow_status.previous_sibling
c
@physical_object
params
exit
po.iu_barcode
medium
row
media_type
c
body
c
body
exit
c
lf
@l_cv[:language_type][0][0]
exit
self.class
self
@physical_object.active_component_group.physical_objects
c
@physical_object.current_workflow_status
c
@physical_objects.size
@physical_objects
c
result.class
result.status
result
exit
c
@physical_object.current_workflow_status.status_name == WorkflowStatus::MOLD_ABATEMENT
@physical_object.in_transit_from_storage?
c
!@series && !params[:title][:series_title_text].blank?
@series
@tp
c
!@title.series.nil? && @params[:series_text].blank?
exit
title_params
c
cedar['upload_dir']
exit
c
PhysicalObject.where(id: po_ids).first.iu_barcode
PhysicalObject.where(id: po_ids).size
PhysicalObject.where(id: po_ids)
po_ids
pod_ids
exit
@user.updated_at + SessionsHelper::TIME_OUT < Time.now
c
@user.updated_at + SessionsHelper::TIME_OUT < Time.now
c
session[:return_to]
request.fullpath
c
request.fullpath
c
@wells
@alf
c
u.worksite_location == 'ALF'
u.worksite_location
c
