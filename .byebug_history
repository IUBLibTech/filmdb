c
action_name
c
action_name
c
reload!
cs.status_name != WorkflowStatus::JUST_INVENTORIED_WELLS
(!cs.nil? && !WorkflowStatus.is_storage_status?(cs.status_name)) &&(cs.status_name != WorkflowStatus::JUST_INVENTORIED_ALF || cs.status_name != WorkflowStatus::JUST_INVENTORIED_WELLS)
cs.status_name
cs.status_name != WorkflowStatus::JUST_INVENTORIED_WELLS
c
flash.now[:warning]
flash[:warning]
flash[:warning] ? 'true' : 'false'
c
flash[:warning] ? flash[:warning] : flash.now[:warning]
flash[:warning] ? 'true' : 'false'
flash.now[:warning]
flash[:warning]
c
flash[:warning]
c
flash[:warning].html_safe
flash[:warning]
c
failed.size
failed
c
workflow_type_from_status(status_name)
c
workflow_type_from_status(status_name)
exit
status_name
workflow_type_from_status(status_name)
c
WorkflowStatus.is_storage_status?(p.current_workflow_status)
p.current_workflow_status
p
c
physical_objects[0].current_workflow_status
physical_objects.any?{|p| p.titles_text.size > 0 }
physical_objects.any?
physical_objects
p
p.current_workflow_status
c
params
c
PhysicalObject.last.storage_location
reload!
current_workflow_status == WorkflowStatus::JUST_INVENTORIED_WELLS
current_workflow_status
current_workflow_status == WorkflowStatus::JUST_INVENTORIED_WELLS
WorkflowStatus::JUST_INVENTORIED_WELLS
current_workflow_status
current_workflow_status == WorkflowStatus::JUST_INVENTORIED_WELLS || current_workflow_status == WorkflowStatus::JUST_INVENTORIED_ALF
WorkflowStatus.where(physical_object_id: id, status_name: WorkflowStatus::IN_STORAGE_INGESTED).size > 0
c
sf
c
row[column_index STOCK]
c
row[column_index STOCK]
c
column_index STOCK
row[column_index STOCK]
c
row[column_index STOCK]
c
date
match[6]
c
match[1]
date
exit
match[1]
match
match[5]
date
c
self.date_text
c
self.date_text
c
self.date_text
exit
match
date
exit
date
dates
exit
match[5]
@title_date_types
exit
@title_date_cv[:date_type].collect{ |d| d[0]}
@title_date_cv[:date_type].collect{ |d| d[0][0]}
@title_date_cv[:type].collect{ |d| d[0][0]}
@title_date_cv.collect{ |d| d[0][0]}
@title_date_types
@title_date_cv
match
exit
match[0]
match
exit
match
c
date
match
exit
/^([\[\]0-9\/\?]+( [-\xE2\x80\x94\xE2\x80\x93]{1,1} ?[\[\]0-9]+)?)( \(([a-zA-Z ]+)\))?$/.match(date)
date
c
exit
date
exit
date
exit
/^([0-9 -\[\]]+)\(([a-zA-Z ]+)\){0,1}$/.match(date)
/^([0-9 -\[\]]+) [\(([a-zA-Z ]+\))]{0,1}$/.match(date)
match
date
match
c
match
c
match
c
match
c
match
c
match
c
match
c
match
c
match
c
exit
params
exit
collection_id
exit
sql
c
sql
c
collection_id.blank?
date.blank?
publisher_text.blank?
c
publisher_text.blank?
publisher_text
c
params
c
params
c
td.date_to_s
c
td.to_s
c
td.to_s
self.to_string
td
c
td.to_s
td
c
self.to_s
self.to_string
self
c
self
c
options_for_select(@title_date_cv[:date_type])
@title_date_cv
c
exit
params[:cage][:mdpi_barocde]
c
!@physical_object.current_workflow_status.valid_next_workflow?(WorkflowStatus::IN_CAGE)
@physical_object.current_workflow_status.valid_next_workflow?(WorkflowStatus::IN_CAGE)
exit
@physical_object.current_workflow_status.valid_next_workflow?(WorkflowStatus::IN_CAGE)
exit
@physical_object.current_workflow_status.valid_next_workflow?(WorkflowStatus::IN_CAGE)
@physical_object.current_workflow_status
@physical_object.current_workflow_status.valid_next_workflow?(WorkflowStatus::IN_CAGE)
exit
params[:cage]
params[:cage].&[:physical_object_mdpi_barcode]
exit
mbc
c
NONPACKABLE_GAUAGES.include?(@physical_object.gauge)
exit
c
PhysicalObjectsHelper::GAUGES_TO_FRAMES_PER_FOOT["16mm"]
exit
PhysicalObjectsHelper::GAUGES_TO_FRAMES_PER_FOOT["16mm"]
PhysicalObjectsHelper.reload
PhysicalObjectsHelper.reload!
PhysicalObjectsHelper::GAUGES_TO_FRAMES_PER_FOOT["16mm"]
PhysicalObjectsHelper::GAUGES_TO_FRAMES_PER_FOOT
PhysicalObjectsHelper::GAUGES_TO_FRAMES_PER_FOOT[p.gauge.to_s]
PhysicalObjectsHelper::GAUGES_TO_FRAMES_PER_FOOT[p.gauge]
p.gauge
c
p.current_workflow_status.component_group
c
(STATUS_TYPES_TO_STATUSES['Storage'] << DEACCESSIONED).include?(status_name) ? nil : physical_object.active_component_group.id
exit
(STATUS_TYPES_TO_STATUSES['Storage'] << DEACCESSIONED).include? status_name ? nil : physical_object.active_component_group.id
(STATUS_TYPES_TO_STATUSES['Storage'] << DEACCESSIONED).include? status_name
(STATUS_TYPES_TO_STATUSES['Storage'] << DEACCESSIONED).include?(status_name) ? nil : physical_object.active_component_group.id
(STATUS_TYPES_TO_STATUSES['Storage'] << DEACCESSIONED).include? status_name
status_name
(STATUS_TYPES_TO_STATUSES['Storage'] << DEACCESSIONED).include? status_name ? nil : physical_object.active_component_group.id
(STATUS_TYPES_TO_STATUSES['Storage'] << DEACCESSIONED).include? status_name ? nil : physical_object.active_component_group.id)
((STATUS_TYPES_TO_STATUSES['Storage'] << DEACCESSIONED).include? status_name ? nil : physical_object.active_component_group.id))
c
ws
w
c
physical_object.active_component_group
physical_object
p
c
p.active_component_group
exit
ControlledVocabulary.physical_object_cv
ControlledVocabulary
@cv[attr_symbol]
attr_symbol
val
exit
Series.series_not_in_spreadsheet(params[:series].to_i, @spreadsheet)
Series.series_in_spreadsheet(Series.find(params[:series].to_i).title, @spreadsheet.id).size
Series.series_in_spreadsheet(Series.find(params[:series].to_i).title, @spreadsheet.id)
Series.find(params[:series].to_i).title
exit
Series.find(params[:series].to_i).title
params[:series].to_i
eries.find(params[:series].to_i).title
eries.find(params[:series]).title
params[:series]
exit
ComponentGroup.new
cg
c
exit
cg
