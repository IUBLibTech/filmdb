c
id
c
pattern.match(@continue_url)
pattern
id
c
/([0-9]+)/.match(@continue_url)[0]
pattern
pattern.match(@continue_url)
id
c
n
@continue_url.include?('collection')
n
@continue_url == new_physical_object_path
c
@continue_url.include?('collection')
n
c
session[:physical_object_create_action]
c
@continue_text
@continue_url.include?('collection')
@continue_url
@continue_text
c
@continue_url[:id]
@continue_url
c
po.research_value
n
k
k.include? (rv)
c
 @cv[:research_value].collect { |x| x[0] }[0].include?(rv)
c
 @cv[:research_value].collect { |x| x[0] }[0].include?(rv)
rv
c
 @cv[:research_value].collect { |x| x[0] }[0].include?(rv)
 @cv[:research_value].collect { |x| x[0] }
rv
c
error
n
error_msg
c
po.condition_rating
n
k.include?(cr)
k
c
k
c
k.include?(cr)
c
k.include?(cr)
c
cr
k.include?(cr)
c
cr
k.include?(cr)
k
c
k
c
@cv[:condition_rating].collect { |x| x[0] }[0].include?(cr)
cr
@cv[:condition_rating].collect { |x| x[0] }
matcher
cr
cf
c
matcher[1]
PhysicalObject::CONDITION_FIELDS
PhysicalObject::CONDITION_FIELDS.include?(matcher[1].parameterize.underscore.to_sym)
matcher
c
/#{cf.downcase}$/.match(pcf.to_s)
pcf.to_s.match(/#{cf.downcase}$/)
pcf.to_s.match(/#{cf.downcase}$/
pcf.to_s.match(/#{cf.lower}$/
pcf
c
pcf
c
pcf
c
pcf
cf
n
/#{cf}$/.match(pcf.to_s)
cf
pcf
c
p.match("foobar")[1]
p.match("foobar")[0]
p.match("foobar")
p = /#{a}/
a = "foo"
PhysicalObject::COLOR_FIELDS
PhysicalObject::COLOR_FIELDS.include?(field.to_sym)
n
color_fields
field
c
gf
c
row[column_index GENERATION].split(DELIMITER)
DELIMITER
c
DELIMITER
DELIMITER == " \; "
' \; '.class
DELIMITER.class
DELIMITER == ' \; '
row[column_index GENERATION].split(DELIMITER)
row[column_index GENERATION].split(' \; ')
DELIMITER
DELIMTER
row[column_index GENERATION].split(' \; ')
row[column_index GENERATION].split(DELIMITER)
gf
c
PhysicalObject::STOCK_FIELDS
PhysicalObject::STOCK_FIELDS.include?(sf)
(field << "=").to_sym
n
"stock #{sf}".parameterize.underscore
po.stock_agfa
sf
c
FRAME_RATE
GENERATION
row[column_index GENERATION]
exit
can
c
@cv[attr_symbol].collect { |x| x[0] }
c
exit
c
val
@cv[attr_symbol].collect { |x| x[0] }
@cv[attr_symbol].collect { |x| x[0] }.include? val
c
exit
row[column_index CONDITION_TYPE]
DELIMITER
row[column_index CONDITION_TYPE].split[DELIMITER]
row[column_index CONDITION_TYPE]
c
row[column_index CONDITION_TYPE].split(" \; ")
row[column_index CONDITION_TYPE].split(" ; ")
row[column_index CONDITION_TYPE].split(" ")
row[column_index CONDITION_TYPE]
row[column_index CONDITION_TYPE].class
row[column_index CONDITION_TYPE].split(" ; ")
row[column_index CONDITION_TYPE].split(' ; ')
row[column_index CONDITION_TYPE]
c
af
c
af == "1:33:1"
af
c
row[column_index ASPECT_RATIO]
c
row[column_index ASPECT_RATIO]
c
po.send(:footage=, footage.to_i)
footage.class
footage
po.footage
po.footage = 2
po.footage
c
footage.to_i
footage
c
val
c
@cv.keys
@cv
attr_symbol
c
attr_symbol
c
attr_symbol
c
:sym.to_s.humanize
:sym.to_s.humaize
:sym.parameterize
:sym.titlize
:sym.titleize
:sym.humanize
(:sym.to_s << "=").to_sym
:sym.to_s << "="
:sym << "="
@cv[:gauge].collect { |x| x[0] }
@cv[:gauge]
c
row[42]
@headers["Stock"]
@headers["STOCK"]
@headers
row[STOCK]
DATE
STOCK
c
nil.each do |a| end
row[VERSION]
c
po.send HEADERS_TO_ASSIGNER[k], row[@headers[k]]
c
po.captions_or_subtitles
po.send HEADERS_TO_ASSIGNER[k], row[@headers[k]]
HEADERS_TO_ASSIGNER[k]
c
po.attributes
po.overall_condition
HEADERS_TO_ASSIGNER[k]
po.send HEADERS_TO_ASSIGNER[k], row[@headers[k]]
c
po.send HEADERS_TO_ASSIGNER[k], row[@headers[k]]
c
po.send HEADERS_TO_ASSIGNER[k], row[@headers[k]]
HEADERS_TO_ASSIGNER[k]
row[@headers[k]]
@headers[k]
exit
@headers[k]
k
@headers
row[@headers[k]]
exit
row[@headers[k]]
@headers[k]
@headers
COLUMN_HEADERS.find_index(k)
COLUMN_HEADERS.find_index(k)]
exit
c
HEADERS_TO_ASSIGNER[k]
k
c
ch
c
ch
c
COLUMN_HEADERS[SUMMARY]
ch
c
ch
