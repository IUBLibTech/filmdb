c
Video::PICTURE_TYPE_FIELDS_HUMANIZED.values
pf
exit
Video::PICTURE_TYPE_FIELDS_HUMANIZED
pf
c
Video::PICTURE_TYPE_FIELDS.include?(field.to_sym)
Video::PICTURE_TYPE_FIELDS
(Video::PICTURE_TYPE_FIELDS
field.to_sym
field
pf
c
exit
cr.split('').each_with_index do |c, i| puts "#{c} == #{test[i]}? #{c == test[i]}\n" end
test = "5 - Possibly Unplayable".split('')
test = "5 - Possibly Unplayable".split
cr.each_with_index do |c, i| puts "#{c} == #{test[i]}? #{c == test[i]}\n" end
test = "5 - Possibly Unplayable"
"5 - Possibly Unplayable".size
cr.size
cd.to_chars
cd.to_array
cd.to_a
cr - "5 - Possibly Unplayable"
cr == "5 - Possibly Unplayable"
cf == "5 - Possibly Unplayable"
cr
@cv[:overall_condition_rating].collect { |x| x[0] }.include? cr
@cv[:overall_condition_rating].collect { |x| x[0] }
@cv[:overall_condition_rating]
@cv[:overall_condition_rating].
@cv
c
matcher
n
c
exit
cf
pattern.match(cf.downcase)
pattaer.match(cf.downcase)
matcher
n
cv[:rated_condition_rating]
v[:rated_condition_rating]
val_conditions
c
bool_conditions.include?(cf.downcase)
c
n
condition_fields
cf
val_conditions
exit
"picture #{pf}".parameterize.underscore
picture_fields
field
c
exit
@cv[attr_symbol]
attr_symbol
c
(par << "=").to_sym
par
exit
po
exit
eit
CAPTIONS_OR_SUBTITLE_NOTES
CAPTIONS_OR_SUBTITLES_NOTES
CAPTIONS_OR_SUBTITLES
c
params[:medium_changed]
params
exit
@physical_object.base_nitrate
@physical_object.medium.base_nitrate
@physical_object.is_a?(Film)
@physical_object
c
n
@physical_object
exit
n
params
c
@physical_object
c
params
n
c
params
n
params[original]
params[medium]
params[:film]
medium
params
params[:original]
params[:medium]
n
medium
original
n
params
exit
params
exit
params
exit
params
exit
params
params = params.except(:video)
params[:video]
params
params.except(:video)
params.keys
params
n
medium
n
original
n
params[:medium_changed]
params
exit
params
exit
params
c
exit
params
c
params[:film][:alternative_title]
params[:film][:alternative_title
params[:film]
params
n
params
c
n
params
c
exit
c
params
exit
params
exit
params
c
params
c
params
c
@physical_object
c
@physical_object
c
params
exit
COLUMN_HEADERS
TITLE
COLUMN_HEADERS[TITLE]
@headers
c
exit
row
exit
@headers
@csv[0]
@csv
exit
medium
exit
medium_index
exit
medium
c
Socket.gethostname
exit
count
exit
cl.where(bf => true).joins("INNER JOIN physical_objects ON physical_objects.actable_id = #{cl.to_s.downcase.pluralize}.id").where(po_sql_where)
bf
po_sql_where
count
c
cl.where(generation_b_roll: true)
cl.where( true)
cl::GENERATION_FIELDS
cl
exit
c
exit
params
c
params
exit
params.to_json
c
params.to_json
params
params.nil?
c
@url
c
exit
action_name
@url
physical_object_path(@physical_object.acting_as.id)
@physical_object.acting_as.id
@physical_object.acting_as
@physical_object.acting_as.id
@url
c
@method
@url
c
new_physical_object_path
new_physical_objects_path
physical_objects_path
action_name
c
url
c
@physical_object.titles_text
@physical_object.current_location
@physical_object.current_location == WorkflowStatus::MOLD_ABATEMENT
@physical_object.specific.has_attribute?(:mold)
@physical_object.specific.
@physical_object
c
@physical_object.acting_as.save
params
@physical_object.acting_as.actable_type
@physical_object.acting_as
@physical_object
exit
params[:medium_changed]
exit
c
@physical_object.alternative_title
exit
PO_ONLY_ATTRIBTUES.include?(p.parameterize.to_sym)
p
PO_ONLY_ATTRIBTUES.include?(p)
c
PO_ONLY_ATTRIBTUES.include?(p)
@physical_object.send(p+"=", params[class_sym][p])
@physical_object.send(p.underscore.parameterize.to_sym, params[class_sym][p])
@physical_object[:titles_text]
@physical_object.titles_text
@physical_object
