exit
@map
params[:title_map]
@retitled[12670].size
@retitled.keys
exit
exiyt
@checked
c
pos.collect{|p| p.iu_barcode}
pos
pos.colect{|p| p.iu_barcode}
pos.size
@new_cg
@retitled
t_id
@title.id
c
@retitled.keys
exit
@retitled.keys
@retitled
c
exit
params[:titles][t_id.to_s][:component_group][:group_type]
c
n
t_id
c
pos.collect{|p| p.id}
keys.select{|k| !params[:titles][t_id.to_s][:component_group][:component_group_physical_objects_attributes][k][:checked].nil?}
pos
keys.select{|k| !params[:titles][t_id.to_s][:component_group][:component_group_physical_objects_attributes][k][:checked].nil?}
n
params[:titles][t_id.to_s][:component_group][:component_group_physical_objects_attributes].keys
exit
params[:titles][t_id.to_s]
t_id
params[:titles].keys
params[:titles][t_id]
params[:titles]
params
params[:titles][t_id]
c
@map
exit
params[:titles]
h = {}
h = Hash.new
@map
c
@map.to_h
c
@map.to_h
c
@map.to_h
@map
c
physical_objects.first.waiting_active_component_group_members?exit
physical_objects.first.waiting_active_component_group_members?
c
(@count / Title.per_page.to_f).ceil
c
(@count / Title.per_page).to_f.ceil
exit
x
x = 100.0
(@count / Title.per_page)
(@count / Title.per_page).to_f.ceil
exit
(@count / Title.per_page)
(@count / Title.per_page).to_f
@count.to_f
Title.per_page.class
Title.per_page
exit
Title.per_page
@count / Title.per_page
(@count / Title.per_page).ceil
c
exit
@count / 100.0
@count / Title.per_page
@count
(@count / Title.per_page).ceil
c
@count
c
p.active_scan_settings
ComponentGroup.find(7127).title.summary
ComponentGroup.find(7127).title.title_summary
ComponentGroup.find(7127).title.title_text
ComponentGroup.find(7127)
p.active_component_group
c
p.active_component_group
p.active_component_group.title
p.active_component_group
c
p.active_component_group?
p.active_component_group
p
exit
@title.physical_objects.first.current_location
@title.physical_objects.select{|p| (!WorkflowStatus.is_storage_status?(p.previous_location) && (p.current_location != p.previous_location))}.size
@title.physical_objects.select{|p| (!WorkflowStatus.is_storage_status?(p.previous_location) && (p.current_location != p.previous_location))}
c
map
c
map
exit
JSON.parse(params[:title_map])
JSON.parse(title_map)
c
exit
JSON.parse(params[:title_map])
JSON.parse(params[:title_map]
c
exit
c
params
c
exit
flash[:merged]
flash[:merged][:all]
c
flash[:merge][:all]
flash[:merge]
c
exit
Title.find(params[:id])
params[:id]
exit
params[:merge_all] == 'true'
params[:merge_all] == 'false'
@title.in_active_workflow?
@title
c
params
exit
tempTblSql
exit
tempTblSql
tempTableSql
exit
Title.where("title_text like '%#{"Copy's".gsub("'", "\\\\'")%'}
"Copy's".gsub("'", "\\\\'")
"Copy's".gsub("'", "\\\'")
"Copy's".gsub("'", "\'")
"Copy's".gsub("'", "\\'")
"Copy's".gsub("'", "\'")
"Copy's".gsub("'", "\\")
"Copy's".gsub("'", "\\\\'")
"Copy's".gsub("'", "\\\'")
"Copy's".gsub("'", "\\'")
"Copy's".gsub("'", "\'")
title_text.gsub("'", "\\'")
title_text
c
p.active_component_group
p.iu_barcode
p = @component_group.physical_objects.first
p
exit
p.active_scan_settings
ComponentGroup.last.physical_objects
ComponentGroup.last
p.active_component_group
p = @new_cg.physical_objects.first
@new_cg
c
@new_cg.physical_objects.first.iu_barcode
@new_cg.physical_objects.size
@new_cg.physical_objects
@new_cg
exit
@new_cg.physical_objects.size
@new_cg.physical_objects
@new_cg
c
unchecked
checked
exit
params
exit
params
exit
params
exit
params
unchecked
checked
@new_cg
ComponentGroup.last
exit
params[:component_group][:component_group_physical_objects_attributes].keys
params[:component_group][:component_group_physical_objects_attributes]
params[:component_group][:component_group_physical_object_attributes]
params[:component_group][:component_group_physical_object_attributes].keys
params[:component_group[:component_group_physical_object_attributes]]
params[:component_group[:component_group_physical_object_attributes]].keys
params[component_group[component_group_physical_object_attributes]].keys
params
exit
params
c
(action_name == 'edit' && !@collection.nil?)
c
action_name == 'edit' && @collection.nil?
action_name == 'edit' && @collection
action_name == 'edit'
action_name == 'edit' && @collection
exit
@cage.bottom_shelf.identifier
cage.bottom_shelf.identifier
c
set[:start_date][:approximation] = (dates[0][0] == '[' && dates[0][-1] == ']')
set[:start_date]
(dates[0][0] == '[' && dates[0][-1] == ']')
dates
c
n
set[:start_date]
set
set[:start_date][:approximation] = (dates[0][0] == '[' && dates[0][-1] == ']')
set[:start_date]
'[' && dates[0][-1] == ']'
dates[0][0]
exit
dates
c
year[-1]
year
n
match
n
dates
c
@title.title_dates.first
c
date_set[:end_date].nil?
self
n
date_set
exit
JSON.pretty_generate @pp
JSON.pretty_generate(PodPush.find(params[:id]).response)
@pp.class
c
Title.includes(:physical_object_titles).where(physical_object_titles: {title_id: nil}).size
Title.all.size
n
(@unit || @collection || @startTime || @endTime) |= nil
@unit || @collection || @startTime || @endTime
any_filters?
exit
