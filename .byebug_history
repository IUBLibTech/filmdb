c
flash[:merge][:all]
flash[:merge]
c
exit
Title.find(params[:id])
params[:id]
exit
params[:merge_all] == 'true'
params[:merge_all] == 'false'
@title.in_active_workflow?
@title
c
params
exit
tempTblSql
exit
tempTblSql
tempTableSql
exit
Title.where("title_text like '%#{"Copy's".gsub("'", "\\\\'")%'}
"Copy's".gsub("'", "\\\\'")
"Copy's".gsub("'", "\\\'")
"Copy's".gsub("'", "\'")
"Copy's".gsub("'", "\\'")
"Copy's".gsub("'", "\'")
"Copy's".gsub("'", "\\")
"Copy's".gsub("'", "\\\\'")
"Copy's".gsub("'", "\\\'")
"Copy's".gsub("'", "\\'")
"Copy's".gsub("'", "\'")
title_text.gsub("'", "\\'")
title_text
c
p.active_component_group
p.iu_barcode
p = @component_group.physical_objects.first
p
exit
p.active_scan_settings
ComponentGroup.last.physical_objects
ComponentGroup.last
p.active_component_group
p = @new_cg.physical_objects.first
@new_cg
c
@new_cg.physical_objects.first.iu_barcode
@new_cg.physical_objects.size
@new_cg.physical_objects
@new_cg
exit
@new_cg.physical_objects.size
@new_cg.physical_objects
@new_cg
c
unchecked
checked
exit
params
exit
params
exit
params
exit
params
unchecked
checked
@new_cg
ComponentGroup.last
exit
params[:component_group][:component_group_physical_objects_attributes].keys
params[:component_group][:component_group_physical_objects_attributes]
params[:component_group][:component_group_physical_object_attributes]
params[:component_group][:component_group_physical_object_attributes].keys
params[:component_group[:component_group_physical_object_attributes]]
params[:component_group[:component_group_physical_object_attributes]].keys
params[component_group[component_group_physical_object_attributes]].keys
params
exit
params
c
(action_name == 'edit' && !@collection.nil?)
c
action_name == 'edit' && @collection.nil?
action_name == 'edit' && @collection
action_name == 'edit'
action_name == 'edit' && @collection
exit
@cage.bottom_shelf.identifier
cage.bottom_shelf.identifier
c
set[:start_date][:approximation] = (dates[0][0] == '[' && dates[0][-1] == ']')
set[:start_date]
(dates[0][0] == '[' && dates[0][-1] == ']')
dates
c
n
set[:start_date]
set
set[:start_date][:approximation] = (dates[0][0] == '[' && dates[0][-1] == ']')
set[:start_date]
'[' && dates[0][-1] == ']'
dates[0][0]
exit
dates
c
year[-1]
year
n
match
n
dates
c
@title.title_dates.first
c
date_set[:end_date].nil?
self
n
date_set
exit
JSON.pretty_generate @pp
JSON.pretty_generate(PodPush.find(params[:id]).response)
@pp.class
c
Title.includes(:physical_object_titles).where(physical_object_titles: {title_id: nil}).size
Title.all.size
n
(@unit || @collection || @startTime || @endTime) |= nil
@unit || @collection || @startTime || @endTime
any_filters?
exit
po
exit
@headers['Series Part']
c
ControlledVocabulary.new(model_type: 'ComponentGroup', model_attribute: ':group_type', value: val, active_status: true, menu_index: i + 3)
ControlledVocabulary.first.active_status
c
loc
c
@cg.group_type
c
exit
@cg.group_type
loc
c
prev_cg
<<<<<<< HEAD
=======
exit
prev_cg
exit
res.first
res
c
@component_group.group_type == ComponentGroup::BEST_COPY_MDPI_WELLS
@component_group
n
c
params[:color_space]
params
c
params[:component_group][:color_space]
params
exit
p.gauge
PhysicalObjectsHelper::GAUGES_TO_FRAMES_PER_FOOT[p.gauge]
p.gauge
p
exit
hh_mm_sec(calc_estimated_duration(@physical_objects))
@physical_objects.collect{|p| p.titles }.flatten.uniq.size
@physical_objects.collect{|p| p.titles }.flatten.uniq
@physical_objects.collect{|p| p.titles }.flatten
@physical_objects.collect{|p| p.titles }
@physical_objects
exit
@physical_object.workflow_statuses
@physical_object
c
@physical_object.same_active_component_group_members?
c
other_title
c
(cg.title.physical_objects.to_a - cg.physical_objects.to_a)[0].in_storage?
(cg.title.physical_objects.to_a - cg.physical_objects.to_a)[0].current_location
cg.title.physical_objects.to_a - cg.physical_objects.to_a
cg
other_title != @title
other_title
exit
other_title
cg.group_type == ComponentGroup::BEST_COPY_ALF ? WorkflowStatus::BEST_COPY_ALF : WorkflowStatus::BEST_COPY_WELLS
cg.group_type == ComponentGroup::REFORMATTING_MDPI
c
cg
exit
middle_shelf.returned || middle_shelf.mdpi_barcode.nil?
top_shelf.returned || top_shelf.mdpi_barcode.nil?
can_be_shipped?
c
exit
!@physical_object.current_workflow_status.status_name != WorkflowStatus::WELLS_TO_ALF_CONTAINER
@physical_object.current_workflow_status.status_name
!@physical_object.current_workflow_status.status_name != WorkflowStatus::WELLS_TO_ALF_CONTAINER
c
@physical_object.current_location
c
@physical_object.current_workflow_status.status_name == WorkflowStatus::WELLS_TO_ALF_CONTAINER
exit
status_name
current.valid_next_workflow?(status_name, override)
(!current.nil? && !current.valid_next_workflow?(status_name, override))
(current.nil? && !SPREADSHEET_START_LOCATIONS.include?(status_name))
current.nil?
exit
params[:component_group]
params
c
FREEZER_AD_STRIP_VALS.include?(ad_strip)
c
FREEZER_AD_STRIP_VALS.include?(ad_strip)
c
FREEZER_AD_STRIP_VALS.include?(ad_strip)
c
exit
!@physical_object.active_component_group.group_type == 'Best Copy (MDPI - Wells)'
exit
@user.updated_at.localtime + SessionsHelper::TIME_OUT < Time.now.localtime
@user.updated_at.localtime
@user.works_in_both_locations
c
x_low > @page
c
@page
x_low
c
params[:collection_id]
exit
res.first[0]
res.first
res
exit
@count.columns
@count[:count]
@count['count']
@count.class
@count[0]
@count
exit
@count[0].class
@count[0]
@count
exit
Title.titles_not_in_spreadsheet(params[:title], @spreadsheet.id)
@existing_titles
