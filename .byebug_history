c
COLUMN_HEADERS[18].chars
ch.chars
ch
COLUMN_HEADERS[18] == ch
COLUMN_HEADERS[18]ch
COLUMN_HEADERS[18] == ch
COLUMN_HEADERS[18]
DATE_CREATED
COLUMN_HEADERS[0]
COLUMN_HEADERS.include?(ch)
ch
exit
gk
gk[:gid].to_i
exit
gk
c
xit
avalon_url
c
gk
exit
avalon_url
c
gk
exit
avalon_url
c
result.code.to_i == 200
result.code
result
c
Title.pod_group_key_id(po.mdpi_barcode)
n
exit
exiy
avalon_url
c
e
n
gr
n
result.code.to_i == 200
result
c
avalon_url
c
avalon_url
exit
result.code
n
result.code
result
exit
http.request(request)
request.basic_auth(Rails.application.secrets[:pod_service_username], Rails.application.secrets[:pod_service_password])
request.code
http.request(request).status
http.request(request)
http.request
result
exit
c
args.is_a? Hash
args.is_a? ActionController::Parameters
args
n
@spreadsheet.id
c
hri
c
PhysicalObjectDate == self.class
self.class
exit
PhysicalObject.find_by_sql(po_digit_count).size
PhysicalObject.where(po_sql_where).where(digitized: true, collection_id: 17, unit_id: 1).size
PhysicalObject.where(po_sql_where).where(digitized: true, collection_id: 17).size
PhysicalObject.where(po_sql_where).where(digitized: true).size
PhysicalObject.where(po_sql_where).size
PhysicalObject.where(po_sql_where)
po_digit_count
PhysicalObject.find_by_sql(po_digit_count).size
PhysicalObject.where(po_sql_where).where(digitized: true).size
PhysicalObject.where(po_sql_where).where(digitized: true)
PhysicalObject.where(po_sql_where).count(digitized: true)
PhysicalObject.find_by_sql(po_digit_count).size
po_digit_count
PhysicalObject.where(po_sql_where).size
po_sql_where
exit
@physical_object
exit
PhysicalObject.where("iu_barcode = ? OR mdpi_barcode = ?", params[:barcode], params[:barcode]).first.specific
c
PhysicalObjectOldBarcode.first
PreviousBarcode.all
PreviousBarcodes.all
PhysicalObject.where("iu_barcode = ? OR mdpi_barcode = ?", params[:barcode], params[:barcode]).first.specific
c
exit
record.class.method_defined? :acting_as
assigned.class.method_defined? :acting_as
assigned.method_defined :acting_as
assigned.method_defined? :acting_as
assigned.actable
assigned.actable?
puts "Yes" if !assigned.acting_as
puts "Yes" if assigned.acting_as
if assigned.acting_as puts "yes" end
record.acting_as
assigned.acting_as
record.class
record.has_attribute?(:acting_as)
assigned.class
assigned.has_attribute?(:acting_as)
assigned && assigned.is_a?(PhysicalObject) && record != assigned
assigned && (assigned.is_a?(CageShelf) && assigned != record)
!ApplicationHelper.valid_barcode?(value, true)
c
exit
assigned && (assigned.is_a?(CageShelf) && assigned != record)
exit
(assigned && (assigned.is_a?(CageShelf) && assigned != record)) || (assigned && record != assigned.acting_as)
c
assigned.is_a?(CageShelf)
exit
record.is_a? Film
record.is_a Film
record.is_a? PhysicalObject
record.acting_as
record
assigned
c
@csv[01]
@csv[0]
exit
result.match(/<message>(.*?)<\/message>/)[1]
result
c
result
c
gk
c
gr
c
exit
rake db:rollback
result.match(/<group_identifier>(GR[0]+)([1-9][0-9]*)<\/group_identifier>/)[2]
result.match(/<group_identifier>(GR[0]+)([1-9][0-9]*)<\/group_identifier>/)[1]
result.match(/<group_identifier>(GR[0]+)([1-9][0-9]*)<\/group_identifier>/)
result
c
gk
c
exit
result
c
exit
result
c
pod_group_key_identifier.nil?
c
u
c
result
exit
bottom_shelf_id
bottom_shelf
top_shelf
exit
top_shelf
exit
cage
c
cage
self
cage
@cage
c
assigned && assigned != record.acting_as
c
exit
assigned == record.acting_as
assigned == record
ApplicationHelper.valid_barcode?(value, true)
record
assigned
exit
ParserHelper.duplicate_count(VIDEO_HEADERS)
exit
  end
    end
      result << value
    if (count > 1)
    # Collect those with count > 1 into a result array.
  end.each_with_object([ ]) do |(value,count), result|
    hash[value] += 1
    # Keep a count of all the unique values encountered
  array.each_with_object(Hash.new(0)) do |value, hash|
def duplicate_count(array)
VIDEO_HEADERS.uniq.size
VIDEO_HEADERS.size
VIDEO_HEADERS - VIDEO_HEADERS.uniq
exit
VIDEO_HEADERS.uniq.size
PO_HEADERS.uniq.size
VIDEO_HEADERS.size
PO_HEADERS.size
VIDEO_HEADERS.size
VIDEO_HEADERS
exit
  ]
      'OCLC Number', 'Tape Capacity', 'Reel Number', 'Detailed Stock Information'
      'Sound Format Type', 'Series Production Number', 'Sound Field', 'Noise Reduction', 'Recording Standard',
      # missing fields from sample spreadsheet but I'm adding anyway
      'Captions or Subtitles', 'Captions or Subtitles Notes', 'Captions or Subtitles Language',
      'Generation Notes', 'Stock', 'Size', 'Aspect Ratio', 'Sound', 'Color', 'Sound Content Type', 'Dialog Language',
      'Name Authority', 'Creator', 'Publisher', 'Genre', 'Form', 'Subject', 'Series Part', 'Date', 'Location',
      'Picture Type', 'Tape Capacity', 'Playback Speed', 'Alternative Title', 'Title Summary', 'Title Notes',
      'Title', 'Duration', 'Series Name', 'Version', 'Format', 'Generation', 'Original Identifier', 'Base', 'Stock',
PO_HEADERS && [
PO_HEADERS
COLUMN_HEADERS.uniq.size
COLUMN_HEADERS.uniq
COLUMN_HEADERS.size
@csv[0].size
@csv[0] - COLUMN_HEADERS
COLUMN_HEADERS - @csv[0]
COLUMN_HEADERS
HEADERS
row[column_index OCLC_NUMBER]
@csv[0].size
COLUMN_HEADERS.size
@csv[1].size
@csv[1]
@csv
csv
COLUMN_HEADERS.each do |h| puts "#{h}" end
row[column_index REEL_NUMBER]
row[column_index DETAILED_STOCK_INFORMATION]
REEL_NUMBER
DETAILED_STOCK_INFORMATION
c
exit
po.media_type_mediums
exit
xit
exit
IUCAT_TITLE_NO
column_index IUCAT_TITLE_NO
up
help
?
column_constant
c
