<%#
  This file represents inline javascript necessary for setting up the following behavior on physical object creation and update:
  * barcode validation
  * mediam type menu context switching based on selecting media type
  * autocomplete for title selection
  * autocomplete for series selection
  * accordion hidden fields for collection specific physical object creation (when metadata fields can be omitted)
%>
<script type="text/javascript">
  // hook in validator for the IU barcode field
  $("#physical_object_iu_barcode").bind("input", function () {
    validateIUBarcode($(this));
  });
  $("#physical_object_mdpi_barcode").bind("input", function () {
    validateMdpiBarcode($(this));
  });

  // hook in handles for the event change on media type
  var media_type_mediums = <%= PhysicalObject::MEDIA_TYPE_MEDIUMS.to_json.html_safe %>;
  $('#media_type').change(function() {
    media = $("#media_type option:selected").val();
    mediums = media_type_mediums[media];
    $("#medium_types").empty();
    $.each(mediums, function(index, value) {
      $("#medium_types").append($("<option></option>").attr("value", value).text(value));
    });
  });

  // if the collection metadata configuration is in effect
  $( function() {
    $( "#accordion" ).accordion({
      collapsible: true,
      active: false
    });
  });

  /*
  Automcomplete is a bit complicated because it has dependencies on what is selected first (series vs. title). There are
  three cases that need to be handled:

  1) A known series is selected first in which case, autocomplete on title should only suggest titles that are part of the
  selected series.
  2) A know title is selected, in which case, if it belongs to a series, the series is set for the physical object and the
  editable ability of the series title is disabled
  3) some combination of know title or series but unknown opposite (know title, unknow series OR know series, unknown title)

  The handlers work as follows: when a series/title field gains focus remove the autcomplete if it is installed the install the
  correct autocompleter based on whether a series is set
   */

  // autocomplete for titles
  $('#physical_object_title_text').focus(function() {
    if ($(this).data('autocomplete')) {
      $(this).autocomplete("destroy");
      $(this).removeData("autocomplete");
    }
    var series_val = series_value();
    var source = '';
    if (typeof series_val === 'undefined' || series_val == '') {
      source = '../../../autocomplete_title';
    } else {
      source = '../../../autocomplete_title_for_series/'+series_val+"/";
    }
   $(this).autocomplete({
      minLength: 2,
      source: source,
      focus: function (event, ui) {
        $(".ui-autocomplete > li").attr("title", ui.item.summary);
        return false;
      },
      select: function (event, ui) {
        // need to check if a title is selected that has a series
        /*series_id = ui.item.series_id
        series_title = ui.item.series_title
        if (series_id != null) {
          $("#physical_object_series_title_text").val(series_title);
          $('#physical_object_series_id').val(series_id);
          // whenever a title is selected we need to disable the series_title_text field
          $("#physical_object_series_title_text").prop('disabled', true);
        }
        $('#physical_object_title_text').removeClass('bad_barcode');
        $("#physical_object_title_text").val(ui.item.label);
        $('#physical_object_title_id').val(ui.item.value);
        */
        $('#physical_object_title_text').removeClass('bad_barcode');
        $("#physical_object_title_text").val('');
        addTitle(ui.item.label, ui.item.value);
        return false;
      }
    });
  });

  // when typing takes place in title_text, clear the hidden title_id value as it should only be set by selecting from
  // the autocomplete list. Additionally we need to unlock series title text incase it was locked from a previous title
  // selection
  $('#physical_object_title_text').keydown(function() {
    $('#physical_object_title_text').addClass('bad_barcode');
    $('#physical_object_title_id').removeAttr('value');
    $('#physical_object_series_title_text').val('');
    $('#physical_object_series_id').removeAttr('value');
  });


  $('#physical_object_collection_text').keypress(function() {
    $('#physical_object_collection_id').removeAttr('value');
    <% unless controller.class == CollectionsController %>
    // collection controller should never enable the unit text field as this and collection are fixed
    el = $('#physical_object_unit_id');
//    if (el.attr('disabled') == 'disabled') {
//      el.attr('disabled', false);
//    }
    <% end %>
  })

  //autcomplete for collections
  $('#physical_object_collection_text').focus(function() {
    if ($(this).data('autocomplete')) {
      $(this).autocomplete("destroy");
      $(this).removeData("autocomplete");
    }
    var unit_val = $('#physical_object_unit_id option:selected').attr('value');
    var source = '../../../autocomplete_collection_for_unit/'+unit_val+"/";
    $(this).autocomplete({
      minLength: 2,
      source: source,
      focus: function (event, ui) {
        //$(".ui-autocomplete > li").attr("title", ui.item.description);
        return false;
      },
      select: function (event, ui) {
        // need to set the unit if a collection is selected
        unit_id = ui.item.unit_id
        unit_title = ui.item.abbreviation
        if (unit_id != null) {
          $("#physical_object_unit_text").val(unit_title);
          $('#physical_object_unit_id').val(unit_id);
          // whenever a collection is selected we need to disable the Unit select element
          //$("#physical_object_unit_id").prop('disabled', true)
        }
        $("#physical_object_collection_text").val(ui.item.label);
        $('#physical_object_collection_id').val(ui.item.value);

        return false;
      }
    });
  });
  $('#title_popup_cancel_button').click(function() {
    $('#title_popup').hideTitlePopup();
  });
  $('#title_button').click(function() {
    if ($('#title_popup').is(':visible') == false) {
      // the url for creating a new title through ajax requires a series id: /titles/ajax/new/:series_id
      // if the series_id is omitted, it will resolve to /titles/ajax/:id with and id of 'new'
      //UPDATE: series id should always be 0 - use autocomplete on the new title popup to select an existing series
      series_id = 0;
      $.ajax({
        url: window.location.protocol + '//' + window.location.host + '/titles/ajax/new/'+series_id,
        error: function(result) {
          x = 237;
          alert("Error:\n"+result);
        },
        success: function(result) {
          el = $('#title_popup_content');
          el.html(result);
					// grab any partially typed text user was inputing when the title failed to match
					pt = $('#physical_object_title_text').val();
					$('#title_title_text').val(pt);
          $("#title_popup").showTitlePopup();
          // autocomplete for series
          $('#title_series_title_text').autocomplete({
            source: '../../../autocomplete_series',
            focus: function (event, ui) {
              $(".ui-autocomplete > li").attr("title", ui.item.summary);
              return false;
            },
            select: function (event, ui) {
              $("#title_series_title_text").val(ui.item.label);
              $('#title_series_id').val(ui.item.value);
              return false;
            },
            create: function(event, ui) {
              this.element.css('z-index', '5000')
            }
          });
          create_url = window.location.protocol + '//' + window.location.host + '/titles/ajax/new_title';
          $('#new_title').submit(function(event) {
            event.preventDefault();
            $.ajax({
              data: $(this).serialize(),
              type: $(this).attr('method'),
              dataType: 'json',
              url: create_url,
              success: function (response) {
                if (response['error'] == null) {
									addTitle(response['title_text'], response['title_id'])
                  $('#physical_object_title_text').removeClass('bad_barcode');
                } else {
                  alert(result['error']);
                }
              },
              error: function(result) {
                alert(result['error']);
              },
              complete: function() {
                $('#title_popup').hideTitlePopup();
              }
            });
          });
        }
      })
    }
  });

  jQuery.fn.showTitlePopup = function() {
    $('#overlay').css("display", "block");
    this.css("position", "absolute");
    this.css("display", "block");
    this.css("top", Math.max(0, (($(window).height() - $(this).outerHeight()) / 2) + $(window).scrollTop()) + "px");
    this.css("left", Math.max(0, (($(window).width() - $(this).outerWidth()) / 2) + $(window).scrollLeft()) + "px");
  }

  jQuery.fn.hideTitlePopup = function() {
    $('#overlay').css("display", "none");
    this.css("display", "none");
  }

  function series_value() {
    return $('#physical_object_series_id').first().attr('value');
  };

  function series_id_blank() {
    return (typeof $('#physical_object_series_id').first().attr('value') === 'undefined' || $('#physical_object_series_id').first().attr('value') == '');
  }
  $('#physical_object_base_nitrate').change(function() {
    if ($(this).prop('checked')) {
      alert("Notify Collection Manager Immediately! Nitrate cannot be stored in the ALF.");
    }
  });

  function addTitle(title_text, title_id) {
    if (title_id_already_added(title_id)) {
      sweetAlert(titleText+" has already been associated with this Physical Object");
    } else {
      // javascript "".split(',') returns [""] by design, so we have to remove that element from the array if present
      ids = getSelectedTitleIds();
      ids.push(title_id);
      ids.sort();
      $('#title_ids').attr('value', ids.join(','));
      li = $(document.createElement('li')).attr({id: 'title_'+title_id, class: 'title_li' });
      $(document.createElement('div')).attr('class', 'title_text').html(title_text).appendTo(li);
      remove_div = $(document.createElement('div')).attr('class', 'remove_title_button');
      $(document.createElement('a')).click(function() { removeTitle($(this)); }).html('-').attr({ id: 'remove_title_button_'+title_id, class: 'button', href: '#', 'data-remote': 'true', title: 'Click to remove this Physical Object/Title association' }).appendTo(remove_div);
      remove_div.appendTo(li);
      li.appendTo($('#existing_titles'));
			// clear title text
			$('#physical_object_title_text').removeClass('bad_barcode');
			$("#physical_object_title_text").val('');
    }
  }

  function removeTitle(jqueryObject) {
    id = jqueryObject.attr('id').replace('remove_title_button_', '');
    $('#title_'+id).remove();
    ids = getSelectedTitleIds();
    ids.splice(ids.indexOf(id), 1);
    $('#title_ids').attr('value', ids.join(','));
  }
  //checks whether the specified title id has already been added to the hidden field #title_ids value attribute
  function title_id_already_added(id) {
    ids = $('#title_ids').attr('value').split(',').indexOf(id) > -1;
  }

  //returns $('#title_ids').attr('value') as an array with "" removed
  function getSelectedTitleIds() {
    ids = $('#title_ids').attr('value').split(',');
    if (ids.indexOf("") >= 0) {
      ids.splice(ids.indexOf(""), 1);
    }
    return ids;
  }

</script>
